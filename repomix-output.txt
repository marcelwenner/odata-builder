This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T06:10:23.820Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    ci-cd.yml
src/
  query-builder/
    types/
      expand/
        expand-fields.type.ts
      filter/
        combined-filter.type.ts
        filter-string.type.ts
        query-filter.type.ts
      operator/
        odata-query-operator.type.ts
      orderby/
        orderby-descriptor.type.ts
      utils/
        util.types.ts
    utils/
      expand/
        expand-util.test.ts
        expand-util.ts
      filter/
        combined-filter-util.ts
        filter-utils.test.ts
        filter-utils.ts
        is-query-filter-util.test.ts
        is-query-filter-util.ts
      orderby/
        orderby-utils.test.ts
        orderby-utils.ts
      select/
        select-utils.test.ts
        select-utils.ts
      skip/
        skip-utils.ts
      top/
        top-utils.ts
    index.ts
    query-builder.test.ts
  index.ts
.eslintrc.json
.gitignore
.prettierrc
CODE_OF_CONDUCT.md
LICENSE
package.json
README.md
rollup.config.js
tsconfig.json

================================================================
Files
================================================================

================
File: .github/ISSUE_TEMPLATE/bug_report.md
================
---
name: Bug report
about: Create a report to help us improve
title: "[BUG]"
labels: bug, good first issue
assignees: nbyx

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Codesandbox reproduction**
If possible please provide a codesandbox with the reporduced bug.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

================
File: .github/ISSUE_TEMPLATE/feature_request.md
================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

================
File: .github/workflows/ci-cd.yml
================
name: build and test

on:
  push:
  pull_request:
  release:
    types: [created]
  workflow_dispatch:

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Test
        run: npm test
      - name: Lint
        run: npm run lint
      - name: Build
        run: npm run build
      - name: Prepare package for npm
        run: |
          cp package.json dist/package.json
          cp README.md dist/README.md
          cd dist
          jq '.main = "odata-builder.js"' package.json > tmp.json && mv tmp.json package.json
          jq '.module = "odata-builder.esm.js"' package.json > tmp.json && mv tmp.json package.json
          jq '.types = "odata-builder.d.ts"' package.json > tmp.json && mv tmp.json package.json
      - name: Check if dist directory is empty
        id: check-dist
        run: |
          if [ -z "$(ls -A dist/)" ]; then
            echo "No files found in dist directory, failing the job."
            exit 1
          fi
      - name: Archive build artifacts
        uses: actions/upload-artifact@v2
        with:
          name: dist
          path: dist/

  request-approval:
    if: github.event_name == 'release' && github.event.action == 'created'
    needs: [test-and-build]
    runs-on: ubuntu-latest
    environment:
      name: 'production'
    steps:
      - name: Request Approval
        run: echo "Approval required to proceed to the next job. Check the artifacts and approve if everything is okay."

  publish:
    if: github.event_name == 'release' && github.event.action == 'created'
    needs: request-approval
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Download build artifacts
        uses: actions/download-artifact@v4.1.7
        with:
          name: dist
          path: dist
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
      - name: Publish to NPM
        run: cd dist && npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

================
File: src/query-builder/types/expand/expand-fields.type.ts
================
export type ExpandFields<T> = {
    [K in Extract<keyof T, string>]-?: T[K] extends Record<string, unknown>
        ? {
              [TK in Extract<keyof T[K], string>]-?: T[K][TK] extends Record<
                  string,
                  unknown
              >
                  ? `${K}/${TK}` | K
                  : K;
          }[Extract<keyof T[K], string>]
        : never;
}[Extract<keyof T, string>];

================
File: src/query-builder/types/filter/combined-filter.type.ts
================
import { QueryFilter } from './query-filter.type';

export interface CombinedFilter<T> {
    logic: 'and' | 'or';
    filters: Array<QueryFilter<T> | CombinedFilter<T>>;
}

================
File: src/query-builder/types/filter/filter-string.type.ts
================
import {
    DateFilterFunctions,
    FilterFields,
    FilterOperators,
    GeneralFilterOperators,
    MathFilterFunctions,
    StringFilterOperators,
} from './query-filter.type';

type VerifyFilter<
    TYPE,
    FILTERFUNCTIONS,
    FILTERSTRING,
    OPERATOR,
    FIELD,
    VALUE,
    VALUETYPE,
    SECONDOPERATOR = GeneralFilterOperators,
> = OPERATOR extends FILTERFUNCTIONS
    ? FIELD extends FilterFields<TYPE, VALUETYPE>
        ? VALUE extends VALUETYPE
            ? SECONDOPERATOR extends GeneralFilterOperators
                ? FILTERSTRING
                : 'Second operator is not correct'
            : `Typeof value is not correct`
        : 'Field does not exists on type'
    : 'Operator is not valid';

export type FilterString<
    TYPE,
    FILTERSTRING extends string,
> = FILTERSTRING extends `${infer OPERATOR}(${infer FIELD}, '${infer VALUE}')`
    ? VerifyFilter<
          TYPE,
          StringFilterOperators,
          FILTERSTRING,
          OPERATOR,
          FIELD,
          VALUE,
          string
      >
    : FILTERSTRING extends `${infer FIELD} ${infer OPERATOR} '${infer VALUE}'`
      ? VerifyFilter<
            TYPE,
            FilterOperators<number | string>,
            FILTERSTRING,
            OPERATOR,
            FIELD,
            VALUE,
            string | number
        >
      : FILTERSTRING extends `${infer FIELD} ${infer OPERATOR} ${infer VALUE}`
        ? VerifyFilter<
              TYPE,
              FilterOperators<boolean>,
              FILTERSTRING,
              OPERATOR,
              FIELD,
              VALUE,
              boolean
          >
        : FILTERSTRING extends `${infer OPERATOR}(${infer FIELD}) ${infer SECONDOPERATOR} ${infer VALUE}`
          ? VerifyFilter<
                TYPE,
                DateFilterFunctions | MathFilterFunctions,
                FILTERSTRING,
                OPERATOR,
                FIELD,
                VALUE,
                Date | number,
                SECONDOPERATOR
            >
          : never;

================
File: src/query-builder/types/filter/query-filter.type.ts
================
import { Guid } from '../utils/util.types';

export type QueryFilter<T> = { lambdaOperator?: 'any' | 'all' } & (
    | {
          field: FilterFields<T, boolean>;
          operator: FilterOperators<boolean>;
          value: boolean | null;
          innerField?: LambdaFilterFields<T, boolean>;
      }
    | {
          field: FilterFields<T, string>;
          operator: FilterOperators<string>;
          value: string | null;
          ignoreCase?: boolean;
          innerField?: LambdaFilterFields<T, string>;
          removeQuotes?: boolean;
      }
    | {
          field: FilterFields<T, Date>;
          operator: FilterOperators<Date>;
          value: Date;
          innerField?: LambdaFilterFields<T, Date>;
      }
    | {
          field: FilterFields<T, Guid>;
          operator: FilterOperators<Guid>;
          value: Guid | null;
          removeQuotes?: boolean;
          innerField?: LambdaFilterFields<T, Guid>;
      }
    | {
          field: FilterFields<T, number>;
          operator: FilterOperators<number>;
          value: number | null;
          innerField?: LambdaFilterFields<T, number>;
      }
);

export type FilterFields<T, VALUETYPE> = {
    [K in Extract<keyof T, string>]: T[K] extends Record<string, unknown>
        ? T[K] extends VALUETYPE
            ? K
            : `${K}/${NestedFilterFields<T[K], VALUETYPE>}`
        : T[K] extends VALUETYPE | null | undefined
          ? K
          : T[K] extends readonly VALUETYPE[]
            ? K
            : T[K] extends readonly Record<string, infer INNERVALUE>[]
              ? INNERVALUE extends VALUETYPE
                  ? K
                  : never
              : never;
}[Extract<keyof T, string>];

type NestedFilterFields<T, VALUETYPE> = {
    [K in keyof T as string]: T[K] extends Record<string, unknown>
        ? T[K] extends VALUETYPE | null | undefined
            ? K
            : `${string & K}/${NestedFilterFields<
                  Exclude<T[K], undefined>,
                  VALUETYPE
              >}`
        : T[K] extends VALUETYPE | null | undefined
          ? K
          : never;
}[Extract<keyof T, string>];

export type LambdaFilterFields<T, VALUETYPE> = {
    [K in Extract<keyof T, string>]-?: T[K] extends readonly (infer TYPE)[]
        ? TYPE extends VALUETYPE
            ? never
            : keyof TYPE
        : never;
}[Extract<keyof T, string>];

export type GeneralFilterOperators = 'eq' | 'ne';

export type StringFilterOperators = 'contains' | 'startswith' | 'endswith';

export type NumberFilterOperators = 'ge' | 'gt' | 'le' | 'lt';

type DateFilterOperators = NumberFilterOperators;

export type DateFilterFunctions =
    | 'day'
    | 'hour'
    | 'minute'
    | 'month'
    | 'second'
    | 'year';

export type MathFilterFunctions = 'round' | 'floor' | 'ceiling';

export type DependentFilterOperators<VALUETYPE> = VALUETYPE extends string
    ? StringFilterOperators
    : VALUETYPE extends number
      ? NumberFilterOperators
      : VALUETYPE extends Date
        ? DateFilterOperators
        : never;

export type FilterOperators<VALUETYPE> =
    | GeneralFilterOperators
    | DependentFilterOperators<VALUETYPE>;

================
File: src/query-builder/types/operator/odata-query-operator.type.ts
================
export type ODataOperators =
    | 'filter'
    | 'count'
    | 'top'
    | 'skip'
    | 'select'
    | 'expand'
    | 'orderby'
    | 'search';

export type OperatorQueryFn = () => string;

export type OperatorOrder = { [key in ODataOperators]: OperatorQueryFn };

================
File: src/query-builder/types/orderby/orderby-descriptor.type.ts
================
export interface OrderByDescriptor<T> {
    field: OrderByFields<T>;
    orderDirection: 'asc' | 'desc';
}

export type OrderByFields<T> = {
    [K in Extract<keyof T, string>]-?: T[K] extends Record<string, unknown>
        ? {
              [TK in Extract<keyof T[K], string>]-?: `${K}/${TK}` | K;
          }[Extract<keyof T[K], string>]
        : K;
}[Extract<keyof T, string>];

================
File: src/query-builder/types/utils/util.types.ts
================
import { CombinedFilter } from '../filter/combined-filter.type';
import { QueryFilter } from '../filter/query-filter.type';
import { OrderByDescriptor } from '../orderby/orderby-descriptor.type';
import { ExpandFields } from '../expand/expand-fields.type';

export type Guid = string & { _type: Guid };
export interface GuidFilter {
    value: Guid;
    removeQuotes?: boolean;
}

export interface QueryComponents<T> {
    count?: string;
    filter?: Set<CombinedFilter<Required<T>> | QueryFilter<Required<T>>>;
    top?: number;
    skip?: number;
    select?: Set<Extract<keyof T, string>>;
    orderBy?: Set<OrderByDescriptor<T>>;
    expand?: Set<ExpandFields<Required<T>>>;
}

================
File: src/query-builder/utils/expand/expand-util.test.ts
================
import { describe, expect, it } from 'vitest';
import { toExpandQuery } from './expand-util';

describe('expand-util', () => {
    it('should return an expand query part with single expand field', () => {
        const item = {
            x: { someProperty: '' },
        };

        const expectedResult = '$expand=x';

        const result = toExpandQuery<typeof item>(['x']);

        expect(result).toBe(expectedResult);
    });

    it('should return expand query with inner field in navigation property', () => {
        const item = {
            x: { someProperty: { code: 's' } },
        };

        const expectedResult = '$expand=x/someProperty';

        const result = toExpandQuery<typeof item>(['x/someProperty']);

        expect(result).toBe(expectedResult);
    });
});

================
File: src/query-builder/utils/expand/expand-util.ts
================
import { ExpandFields } from 'src/query-builder/types/expand/expand-fields.type';

export const toExpandQuery = <T>(expandProps: ExpandFields<T>[]): string => {
    if (expandProps.length === 0) return '';

    return `$expand=${expandProps.join(', ')}`;
};

================
File: src/query-builder/utils/filter/combined-filter-util.ts
================
import { CombinedFilter } from 'src/query-builder/types/filter/combined-filter.type';
import { isQueryFilter } from './is-query-filter-util';

export const isCombinedFilter = <T>(
    filters: unknown,
): filters is CombinedFilter<T> => {
    return (
        ((filters as CombinedFilter<T>).logic === 'and' ||
            (filters as CombinedFilter<T>).logic === 'or') &&
        (filters as CombinedFilter<T>).filters.every(
            filter => isQueryFilter(filter) || isCombinedFilter(filter),
        )
    );
};

================
File: src/query-builder/utils/filter/filter-utils.test.ts
================
import { CombinedFilter } from 'src/query-builder/types/filter/combined-filter.type';
import { QueryFilter } from 'src/query-builder/types/filter/query-filter.type';
import { Guid } from 'src/query-builder/types/utils/util.types';
import { describe, expect, it } from 'vitest';
import { toFilterQuery, toQueryFilterQuery } from './filter-utils';

describe('toQueryFilterQuery', () => {
    it('should not add quotes to guid filter if removeQuotes is true', () => {
        const item = {
            x: '271242cc-9290-4492-9f23-f340782cd26b' as Guid,
        };
        const expectedResult = 'x eq 271242cc-9290-4492-9f23-f340782cd26b';

        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'eq',
            value: '271242cc-9290-4492-9f23-f340782cd26b' as Guid,
            removeQuotes: true,
        };

        const result = toQueryFilterQuery(filter);

        expect(result).toBe(expectedResult);
    });

    it('should not have quotes for boolean type', () => {
        const item = {
            x: true,
        };
        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'eq',
            value: true,
        };
        const expectedResult = 'x eq true';

        const result = toQueryFilterQuery<typeof item>(filter);

        expect(result).toBe(expectedResult);
    });

    it('should not have quotes for number type', () => {
        const item = {
            x: 5,
        };
        const expectedResult = 'x eq 5';
        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'eq',
            value: 5,
        };

        const result = toQueryFilterQuery(filter);

        expect(result).toBe(expectedResult);
    });

    it('should return empty string if not filter type', () => {
        const result = toQueryFilterQuery({} as QueryFilter<unknown>);

        expect(result).toBe('');
    });

    it('should return filter string with any-lambda', () => {
        const item = {
            x: [{ y: '' }],
        };
        const expectedResult = "x/any(s: contains(tolower(s/y), ''))";

        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'contains',
            value: '',
            lambdaOperator: 'any',
            ignoreCase: true,
            innerField: 'y',
        };

        const result = toQueryFilterQuery<typeof item>(filter);

        expect(result).toBe(expectedResult);
    });

    it('should return string filter with object in item that is optional', () => {
        const item: { x: { y?: string; t: string } } = {
            x: {
                y: '',
                t: '',
            },
        };
        const expectedResult = "contains(tolower(x/y), '')";

        const filter: QueryFilter<typeof item> = {
            field: 'x/y',
            operator: 'contains',
            value: '',
            ignoreCase: true,
        };

        const result = toQueryFilterQuery<typeof item>(filter);

        expect(result).toBe(expectedResult);
    });

    it('should return filter string with all-lamda for string array', () => {
        const item = {
            x: [''],
        };
        const expectedResult = "x/any(s: contains(tolower(s), ''))";

        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'contains',
            value: '',
            lambdaOperator: 'any',
            ignoreCase: true,
        };

        const result = toQueryFilterQuery<typeof item>(filter);

        expect(result).toBe(expectedResult);
    });

    it('should return combined filter string with logic or', () => {
        const filter: CombinedFilter<{ x: boolean }> = {
            logic: 'or',
            filters: [
                { field: 'x', operator: 'eq', value: true },
                { field: 'x', operator: 'eq', value: false },
            ],
        };

        const expectedResult = '$filter=(x eq true or x eq false)';

        const result = toFilterQuery<{ x: boolean }>([filter]);

        expect(result).toBe(expectedResult);
    });

    it('should return combined filters string with logic or with filter array', () => {
        const filter1: CombinedFilter<{ x: boolean }> = {
            logic: 'or',
            filters: [
                { field: 'x', operator: 'eq', value: true },
                { field: 'x', operator: 'eq', value: false },
            ],
        };

        const filter2: CombinedFilter<{ x: boolean }> = {
            logic: 'and',
            filters: [
                { field: 'x', operator: 'eq', value: true },
                { field: 'x', operator: 'eq', value: false },
            ],
        };

        const expectedResult =
            '$filter=(x eq true or x eq false) and (x eq true and x eq false)';

        const result = toFilterQuery<{ x: boolean }>([filter1, filter2]);

        expect(result).toBe(expectedResult);
    });

    it('should return combined filters string with date values', () => {
        const date = new Date(Date.now());
        const expectedResult = `$filter=(x eq ${date.toISOString()} or x eq ${date.toISOString()})`;

        const filter: CombinedFilter<{ x: Date }> = {
            logic: 'or',
            filters: [
                { field: 'x', operator: 'eq', value: date },
                { field: 'x', operator: 'eq', value: date },
            ],
        };

        const result = toFilterQuery<{ x: Date }>([filter]);

        expect(result).toBe(expectedResult);
    });

    it('should return combined filters with another combined filter in it', () => {
        const expectedResult = `$filter=((x eq 'test' or x eq 'test1') and (y eq 'test2' or y eq 'test3') and z eq 'test4')`;

        interface dto {
            x: string;
            y: string;
            z: string;
        }

        const filters: CombinedFilter<dto> = {
            logic: 'and',
            filters: [
                {
                    logic: 'or',
                    filters: [
                        { field: 'x', operator: 'eq', value: 'test' },
                        { field: 'x', operator: 'eq', value: 'test1' },
                    ],
                },
                {
                    logic: 'or',
                    filters: [
                        { field: 'y', operator: 'eq', value: 'test2' },
                        { field: 'y', operator: 'eq', value: 'test3' },
                    ],
                },
                { field: 'z', operator: 'eq', value: 'test4' },
            ],
        };

        const result = toFilterQuery<dto>([filters]);

        expect(result).toBe(expectedResult);
    });

    it('should return string wieh null value for combined filter', () => {
        const expectedResult = '$filter=(x eq null)';

        const filter: CombinedFilter<{ x: null }> = {
            logic: 'or',
            filters: [{ field: 'x', operator: 'eq', value: null }],
        };

        const result = toFilterQuery<{ x: null }>([filter]);

        expect(result).toBe(expectedResult);
    });

    it('should return string with null value for query filter', () => {
        const expectedResult = 'x eq null';

        const filter: QueryFilter<{ x: null }> = {
            field: 'x',
            operator: 'eq',
            value: null,
        };

        const result = toQueryFilterQuery<{ x: null }>(filter);

        expect(result).toBe(expectedResult);
    });
});

================
File: src/query-builder/utils/filter/filter-utils.ts
================
import { CombinedFilter } from 'src/query-builder/types/filter/combined-filter.type';
import {
    QueryFilter,
    StringFilterOperators,
} from 'src/query-builder/types/filter/query-filter.type';
import { GuidFilter } from 'src/query-builder/types/utils/util.types';
import { isCombinedFilter } from './combined-filter-util';

export const toFilterQuery = <T>(
    filters: Array<QueryFilter<T> | CombinedFilter<T>>,
): string => {
    if (filters.length === 0) return '';

    return filters.reduce(
        (prev, curr, index) =>
            prev +
            `${index > 0 ? ' and ' : ''}${
                isCombinedFilter<T>(curr)
                    ? getCombinedFilterQuery(curr)
                    : toQueryFilterQuery(curr)
            }`,
        '$filter=',
    );
};

export const getCombinedFilterQuery = <T = string>(
    compositeFilter: CombinedFilter<T>,
): string =>
    compositeFilter.filters.length > 0
        ? `(${compositeFilter.filters.reduce(
              (prev, curr, index, array) =>
                  prev +
                  (isCombinedFilter<T>(curr)
                      ? getCombinedFilterQuery<T>(curr) +
                        ` ${compositeFilter.logic} `
                      : `${toQueryFilterQuery(curr)}${
                            index < array.length - 1
                                ? ` ${compositeFilter.logic} `
                                : ''
                        }`),
              '',
          )})`
        : '';

export const toQueryFilterQuery = <T>(filter: QueryFilter<T>): string => {
    if (filter.value === null) return `${filter.field} ${filter.operator} null`;

    if (
        typeof filter.value === 'string' &&
        ((!isGuidFilter(filter) && !filter.lambdaOperator) ||
            (isGuidFilter(filter) && !filter.removeQuotes))
    ) {
        return getStringFilter(filter, filter.field);
    }

    if (
        !filter.lambdaOperator &&
        ((isGuidFilter(filter) && filter.removeQuotes) ||
            typeof filter.value === 'boolean' ||
            typeof filter.value === 'number' ||
            filter.value instanceof Date)
    ) {
        return `${filter.field} ${filter.operator} ${getFilterValue(filter)}`;
    }

    if (filter.lambdaOperator) {
        return `${filter.field}/${filter.lambdaOperator}(s: ${getStringFilter(
            filter,
            `s${
                (filter.innerField as string)
                    ? `/${filter.innerField as string}`
                    : ''
            }`,
        )})`;
    }
    return '';
};

const isStringFilterFunction = (x: unknown): x is StringFilterOperators => {
    return (
        typeof x === 'string' &&
        (x === 'contains' || x === 'startswith' || x === 'endswith')
    );
};

const hasIgnoreCase = <T>(filter: QueryFilter<T>): boolean => {
    return 'ignoreCase' in filter && filter.ignoreCase;
};

const isGuidFilter = (filter: unknown): filter is GuidFilter => {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(
        (filter as GuidFilter).value,
    );
};

function getFieldValue(field: string, hasIgnoreCase: boolean) {
    return `${hasIgnoreCase ? 'tolower(' : ''}${field}${
        hasIgnoreCase ? ')' : ''
    }`;
}

const getStringFilter = <T>(filter: QueryFilter<T>, field: string): string => {
    if (filter.value === null) return `${field} ${filter.operator} null`;

    return isStringFilterFunction(filter.operator)
        ? `${filter.operator}(${getFieldValue(
              field,
              hasIgnoreCase(filter),
          )}, '${getStringFilterValue(
              filter.value.toString(),
              hasIgnoreCase(filter),
          )}')`
        : `${getFieldValue(field, hasIgnoreCase(filter))} ${
              filter.operator
          } '${getStringFilterValue(
              filter.value.toString(),
              hasIgnoreCase(filter),
          )}'`;
};

const getStringFilterValue = (value: string, hasIgnoreCase: boolean) => {
    return hasIgnoreCase ? value.toLowerCase() : value;
};

const getFilterValue = <T>(filter: QueryFilter<T>) => {
    if (filter.value === null) return 'null';

    if (filter.value instanceof Date) return filter.value.toISOString();

    return filter.value.toString();
};

================
File: src/query-builder/utils/filter/is-query-filter-util.test.ts
================
import { QueryFilter } from 'src/query-builder/types/filter/query-filter.type';
import { describe, expect, it } from 'vitest';
import { isQueryFilter } from './is-query-filter-util';

describe('isQueryFilter', () => {
    it('should return true', () => {
        const filter: QueryFilter<{ Code: 5 }> = {
            field: 'Code',
            operator: 'eq',
            value: 5,
        };

        expect(isQueryFilter(filter)).toBeTruthy();
    });

    it('should return false', () => {
        const filter = {
            field: 'Code',
        };

        expect(isQueryFilter(filter)).toBeFalsy();
    });

    it('should return true with field boolean', () => {
        const filter: QueryFilter<{ Code: true }> = {
            field: 'Code',
            operator: 'eq',
            value: false,
        };

        expect(isQueryFilter(filter)).toBeTruthy();
    });

    it('should return lambda operation', () => {
        const item = {
            x: [{ y: '' }],
        };

        const filter: QueryFilter<typeof item> = {
            field: 'x',
            operator: 'contains',
            value: '',
            lambdaOperator: 'any',
            innerField: 'y',
        };

        expect(isQueryFilter(filter)).toBeTruthy();
    });
});

================
File: src/query-builder/utils/filter/is-query-filter-util.ts
================
import { QueryFilter } from '../../types/filter/query-filter.type';

export const isQueryFilter = <T>(filter: unknown): filter is QueryFilter<T> => {
    return (
        (!!filter &&
            !!(filter as QueryFilter<T>).field &&
            !!(filter as QueryFilter<T>).operator &&
            (typeof (filter as QueryFilter<T>).value === 'string' ||
                typeof (filter as QueryFilter<T>).value === 'boolean' ||
                typeof (filter as QueryFilter<T>).value === 'number' ||
                (filter as QueryFilter<T>).value instanceof Date)) ||
        (filter as QueryFilter<T>).value === null
    );
};

================
File: src/query-builder/utils/orderby/orderby-utils.test.ts
================
import { describe, expect, it } from 'vitest';
import { toOrderByQuery } from './orderby-utils';

describe('toOrderByQuery', () => {
    it.each(['asc', 'desc'])(
        'should return one order by prop with correct ordering',
        orderDirection => {
            const orderBys = [
                {
                    field: 'test',
                    orderDirection: orderDirection as 'asc' | 'desc',
                } as const,
            ];
            const expectedResult = `$orderby=test ${orderDirection}`;
            const result = toOrderByQuery(orderBys);

            expect(result).toBe(expectedResult);
        },
    );

    it('should return two order by props with correct ordering', () => {
        const orderBys = [
            { field: 'aIOJd3', orderDirection: 'asc' } as const,
            { field: 'test', orderDirection: 'desc' } as const,
        ];
        const expectedResult = '$orderby=aIOJd3 asc, test desc';

        const result = toOrderByQuery(orderBys);

        expect(result).toBe(expectedResult);
    });
});

================
File: src/query-builder/utils/orderby/orderby-utils.ts
================
import { OrderByDescriptor } from 'src/query-builder/types/orderby/orderby-descriptor.type';

export const toOrderByQuery = <T>(orderBy: OrderByDescriptor<T>[]) => {
    if (orderBy.length === 0) return '';

    const orderByFields = orderBy.reduce(
        (prev, curr, index, array) =>
            prev +
            `${curr.field} ${curr.orderDirection}${
                index < array.length - 1 ? ', ' : ''
            }`,
        '',
    );

    return `$orderby=${orderByFields}`;
};

================
File: src/query-builder/utils/select/select-utils.test.ts
================
import { describe, expect, it } from 'vitest';
import { toSelectQuery } from './select-utils';

describe('toSelectQuery', () => {
    it('should return the select query string with one select prop', () => {
        const selectProps = ['test'];
        const expectedResult = '$select=test';

        const result = toSelectQuery(selectProps);

        expect(result).toBe(expectedResult);
    });

    it('should return select query with more than one select prop', () => {
        const selectProps = ['test', 'test2', 'test3'];
        const expectedResult = '$select=test, test2, test3';

        const result = toSelectQuery(selectProps);

        expect(result).toBe(expectedResult);
    });
});

================
File: src/query-builder/utils/select/select-utils.ts
================
export function toSelectQuery(select: string[]): string {
    if (select.length === 0) return '';

    return `$select=${select.join(', ')}`;
}

================
File: src/query-builder/utils/skip/skip-utils.ts
================
export const toSkipQuery = (skip: number): string => {
    if (skip < 0) throw new Error('Invalid skip count');
    if (skip === 0) return '';

    return `$skip=${skip}`;
};

================
File: src/query-builder/utils/top/top-utils.ts
================
export const toTopQuery = (top: number): string => {
    if (top < 0) throw new Error('Invalid top count');
    if (top === 0) return '';

    return `$top=${top}`;
};

================
File: src/query-builder/index.ts
================
import { OrderByDescriptor } from './types/orderby/orderby-descriptor.type';
import { QueryFilter } from './types/filter/query-filter.type';
import { toOrderByQuery } from './utils/orderby/orderby-utils';
import { toSelectQuery } from './utils/select/select-utils';
import { toFilterQuery } from './utils/filter/filter-utils';
import { CombinedFilter } from './types/filter/combined-filter.type';
import { ExpandFields } from './types/expand/expand-fields.type';
import { toExpandQuery } from './utils/expand/expand-util';
import { toTopQuery } from './utils/top/top-utils';
import { toSkipQuery } from './utils/skip/skip-utils';
import { QueryComponents } from './types/utils/util.types';

const countEntitiesQuery = '/$count';
export class OdataQueryBuilder<T> {
    private queryComponents: QueryComponents<T> = {};

    top(topCount: number): this {
        if (!topCount || this.queryComponents.top) return this;
        if (topCount < 0) throw new Error('Invalid top count');

        this.queryComponents.top = topCount;

        return this;
    }

    skip(skipCount: number): this {
        if (!skipCount || this.queryComponents.skip) return this;
        if (skipCount < 0) throw new Error('Invalid skip count');

        this.queryComponents.skip = skipCount;

        return this;
    }

    select(...selectProps: Extract<keyof Required<T>, string>[]): this {
        if (selectProps.length === 0) return this;
        if (selectProps.some(prop => !prop))
            throw new Error('Invalid select input');

        return this.addComponent('select', selectProps);
    }

    filter(
        ...filters: (CombinedFilter<Required<T>> | QueryFilter<Required<T>>)[]
    ): this;
    // filter<VALUE extends string>(
    //     ...filters: FilterString<T, VALUE>[]
    // ): OdataQueryBuilder<T>;

    filter(
        ...filters: Array<
            CombinedFilter<Required<T>> | QueryFilter<Required<T>>
        >
    ): this {
        if (filters.length === 0) return this;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (filters.some(filter => !filter))
            throw new Error('Invalid filter input');

        return this.addComponent('filter', filters);
    }

    expand(...expandFields: ExpandFields<T>[]): this {
        if (expandFields.length === 0) return this;
        if (expandFields.some(field => !field))
            throw new Error('Field missing for expand');

        return this.addComponent('expand', expandFields);
    }

    count(countEntities = false): this {
        if (this.queryComponents.count) return this;

        this.queryComponents.count = countEntities
            ? countEntitiesQuery
            : '$count=true';

        return this;
    }

    orderBy(...orderBy: OrderByDescriptor<Required<T>>[]): this {
        if (orderBy.length === 0) return this;

        return this.addComponent('orderBy', orderBy);
    }

    toQuery(): string {
        const queryGeneratorMap: Record<
            keyof QueryComponents<T>,
            (component: QueryComponents<T>[keyof QueryComponents<T>]) => string
        > = {
            count: component => component as string,
            filter: component =>
                toFilterQuery(Array.from(component as Set<QueryFilter<T>>)),
            top: component => toTopQuery(component as number),
            skip: component => toSkipQuery(component as number),
            select: component =>
                toSelectQuery(
                    Array.from(component as Set<Extract<keyof T, string>>),
                ),
            expand: component =>
                toExpandQuery<T>(Array.from(component as Set<ExpandFields<T>>)),
            orderBy: component =>
                toOrderByQuery(
                    Array.from(component as Set<OrderByDescriptor<T>>),
                ),
        };

        const sortedEntries = Object.entries(this.queryComponents).sort(
            ([a], [b]) => {
                const orderA = Object.keys(queryGeneratorMap).indexOf(a);
                const orderB = Object.keys(queryGeneratorMap).indexOf(b);
                return orderA - orderB;
            },
        );

        const queryStringParts: string[] = [];

        for (const [operator, component] of sortedEntries) {
            if (!component) continue;

            const queryPart = queryGeneratorMap[
                operator as keyof QueryComponents<T>
            ](component as QueryComponents<T>[keyof QueryComponents<T>]);
            if (!queryPart) continue;

            queryStringParts.push(queryPart);
        }

        const queryString = queryStringParts.join('&');

        if (queryString.startsWith('/$count')) {
            const remainingQueryString = queryString.slice('/$count'.length);

            if (remainingQueryString.length > 0)
                return `/$count?${remainingQueryString.substring(1)}`;

            return '/$count';
        }

        return queryString.length > 0 ? `?${queryString}` : '';
    }

    private addComponent<
        K extends keyof QueryComponents<T>,
        U = NonNullable<QueryComponents<T>[K]> extends Set<infer V> ? V : never,
    >(type: K, values: U[]): this {
        if (values.length === 0) return this;

        if (!this.queryComponents[type]) {
            this.queryComponents[type] = new Set() as QueryComponents<T>[K];
        }

        const componentSet = this.queryComponents[type] as unknown as Set<U>;
        for (const value of values) {
            componentSet.add(value);
        }

        return this;
    }
}

================
File: src/query-builder/query-builder.test.ts
================
import { expect, describe, it } from 'vitest';
import { OdataQueryBuilder } from '.';
import {
    FilterFields,
    FilterOperators,
} from './types/filter/query-filter.type';
import { Guid } from './types/utils/util.types';

describe('query-builder', () => {
    it('should return an empty string if toQuery is called without function', () => {
        const queryBuilder = new OdataQueryBuilder();

        expect(queryBuilder.toQuery()).toBe('');
    });

    it('should add top to the query', () => {
        const expectedTop = 100;
        const expectedQuery = `?$top=${expectedTop}`;

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.top(expectedTop);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add skip to the query', () => {
        const expectedSkip = 10;
        const expectedQuery = `?$skip=${expectedSkip}`;

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.skip(expectedSkip);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should only add one skip', () => {
        const expectedSkip = 10;
        const expectedQuery = `?$skip=${expectedSkip}`;

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.skip(expectedSkip).skip(1000).skip(5);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should begin with count when choosing count entities', () => {
        const expectedQuery = '/$count';

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.count(true);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should begin with count when choosing count entities and add a filter', () => {
        const item = {
            x: 6,
            y: 4,
        };

        const expectedQuery = '/$count?$filter=x eq 6';

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder
            .filter({ field: 'x', operator: 'eq', value: 6 })
            .count(true);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add the count operator to the query', () => {
        const expectedQuery = '?$count=true';

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.count();

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should only add the first count', () => {
        const expectedQuery = '?$count=true';

        const queryBuilder = new OdataQueryBuilder();
        queryBuilder.count().count().count();

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add select to the query', () => {
        const item = {
            x: 6,
            y: 4,
        };
        const expectedQuery = '?$select=x, y';

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder.select('x', 'y');

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add one select if select is called multiple times', () => {
        const item = {
            x: 6,
            y: 4,
        };
        const expectedQuery = '?$select=x, y';

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder.select('x').select('y');

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add orderby to the query', () => {
        const item = {
            a: 1,
            b: 2,
        };

        const expectedQuery = '?$orderby=a desc';

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder.orderBy({ field: 'a', orderDirection: 'desc' });

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add a number filter to the query', () => {
        const item = {
            x: 1,
        };

        const expectedQuery = '?$filter=x eq 1';

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder.filter({ field: 'x', operator: 'eq', value: 1 });

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it.each([
        { operator: 'eq', ignoreCase: true } as const,
        { operator: 'eq', ignoreCase: false } as const,
        { operator: 'contains', ignoreCase: true } as const,
        { operator: 'contains', ignoreCase: false } as const,
    ])('should add a string filter to the query', filterOption => {
        const item = {
            x: '1',
        };

        const filter = {
            field: 'x',
            value: '1',
            operator: filterOption.operator,
            ignoreCase: filterOption.ignoreCase,
        } as const;

        const expectedQuery =
            '?$filter=' +
            (filterOption.operator === 'contains'
                ? `contains(${filterOption.ignoreCase ? 'tolower(' : ''}${
                      filter.field
                  }${filterOption.ignoreCase ? ')' : ''}, '${filter.value}')`
                : `${filterOption.ignoreCase ? 'tolower(' : ''}${filter.field}${
                      filterOption.ignoreCase ? ')' : ''
                  } ${filter.operator} '${filter.value}'`);

        const queryBuilder = new OdataQueryBuilder<typeof item>();
        queryBuilder.filter(filter);

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should add space before and when combining two filters', () => {
        interface MyAwesomeDto {
            y: string;
            x: Guid;
        }
        const expectedResult = `?$filter=x eq 76b44f03-bb98-48eb-81fd-63007465a76d and y eq ''`;
        const filter = {
            field: 'x',
            operator: 'eq',
            value: '76b44f03-bb98-48eb-81fd-63007465a76d' as Guid,
            removeQuotes: true,
        } as const;

        const query = new OdataQueryBuilder<MyAwesomeDto>()
            .filter(filter)
            .filter({ field: 'y', operator: 'eq', value: '' })
            .toQuery();

        expect(query).toBe(expectedResult);
    });

    it('should add filter if query builder is in a function', () => {
        interface MyAwesomeDto {
            y: string;
            x: string;
        }
        const expectedResult = `?$filter=x eq 76b44f03-bb98-48eb-81fd-63007465a76d`;

        const getQuery = (queryPart: string) => {
            return new OdataQueryBuilder<MyAwesomeDto>()
                .filter({
                    field: 'x',
                    operator: 'eq',
                    value: queryPart,
                    removeQuotes: true,
                })
                .toQuery();
        };

        expect(getQuery('76b44f03-bb98-48eb-81fd-63007465a76d')).toBe(
            expectedResult,
        );
    });
    it('should also filter with optional properties', () => {
        type MyAwesomeDto = { x?: { code: string } } & { y: boolean };
        const expectedResult = "?$filter=x/code eq 'test'";

        const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>();

        queryBuilder.filter({ field: 'x/code', operator: 'eq', value: 'test' });

        expect(queryBuilder.toQuery()).toBe(expectedResult);
    });
    it('should add the filter with lambda combined with non lambda filter', () => {
        const queryBuilder = new OdataQueryBuilder<typeof item>();
        const item = {
            x: [{ y: '' }],
            z: false,
        };
        const expectedResult = `?$filter=x/any(s: contains(s/y, '1')) and z eq false`;

        queryBuilder
            .filter({
                field: 'x',
                operator: 'contains',
                value: '1',
                lambdaOperator: 'any',
                innerField: 'y',
            })
            .filter({ field: 'z', operator: 'eq', value: false });

        expect(queryBuilder.toQuery()).toBe(expectedResult);
    });
    it('should add the filter query also for nullable types', () => {
        interface MyAwesomeDto {
            test: string | null;
        }

        const expectedResult = "?$filter=test eq '1'";

        const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>().filter({
            field: 'test',
            operator: 'eq',
            value: '1',
        });

        expect(queryBuilder.toQuery()).toBe(expectedResult);
    });

    it('should add the filter query also for nullable types in nested properties', () => {
        interface MyAwesomeDto {
            test: { x: string | null };
        }

        const expectedResult = "?$filter=test/x eq '1'";

        const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>().filter({
            field: 'test/x',
            operator: 'eq',
            value: '1',
        });

        expect(queryBuilder.toQuery()).toBe(expectedResult);
    });

    it('should combine the filters regardless of order', () => {
        const item = {
            w: { someProperty: '' },
            x: 't',
            y: 4,
            z: 'test' as Guid,
        };
        const expectedQuery =
            "?$count=true&$filter=z eq '76b44f03-bb98-48eb-81fd-63007465a76d' and (x eq 'test' or y eq 5)&$top=100&$skip=10&$select=x&$expand=w&$orderby=x asc";
        const queryBuilder = new OdataQueryBuilder<typeof item>();

        queryBuilder
            .skip(10)
            .orderBy({ field: 'x', orderDirection: 'asc' })
            .count()
            .top(100)
            .filter({
                field: 'z',
                operator: 'eq',
                value: '76b44f03-bb98-48eb-81fd-63007465a76d' as Guid,
            })
            .filter({
                logic: 'or',
                filters: [
                    { field: 'x', operator: 'eq', value: 'test' },
                    { field: 'y', operator: 'eq', value: 5 },
                ],
            })
            .expand('w')
            .select('x');

        expect(queryBuilder.toQuery()).toBe(expectedQuery);
    });

    it('should return a filter string with computed values for filter', () => {
        const item = {
            x: 4,
            y: 'test',
            z: new Date(Date.now()),
        };
        const expectedQuery = "?$filter=y eq '4'";

        const testFn = (
            field: FilterFields<typeof item, string>,
            operator: FilterOperators<string>,
            value: string,
        ): string => {
            const queryBuilder = new OdataQueryBuilder<typeof item>();

            queryBuilder.filter({ field, operator, value });

            return queryBuilder.toQuery();
        };

        const result = testFn('y', 'eq', '4');

        expect(result).toBe(expectedQuery);
    });

    it('should return a filter string for a deeply nested object', () => {
        const item = {
            x: {
                y: {
                    z: 'test',
                },
            },
        };
        const expectedQuery = "?$filter=x/y/z eq 'test'";

        const queryBuilder = new OdataQueryBuilder<typeof item>();

        queryBuilder.filter({ field: 'x/y/z', operator: 'eq', value: 'test' });

        const result = queryBuilder.toQuery();

        expect(result).toBe(expectedQuery);
    });

    it('should return a filter string with combined filter inside of combined filter', () => {
        const item = {
            x: 'test',
            y: 'test1',
            z: 'test2',
        };
        const expectedQuery = `?$filter=((x eq 'test' or y eq 'test1') and z eq 'test')`;

        const queryBuilder = new OdataQueryBuilder<typeof item>();

        queryBuilder.filter({
            logic: 'and',
            filters: [
                {
                    logic: 'or',
                    filters: [
                        { field: 'x', operator: 'eq', value: 'test' },
                        { field: 'y', operator: 'eq', value: 'test1' },
                    ],
                },
                { field: 'z', operator: 'eq', value: 'test' },
            ],
        });

        const result = queryBuilder.toQuery();

        expect(result).toBe(expectedQuery);
    });
});

================
File: src/index.ts
================
export { OdataQueryBuilder } from './query-builder/index';
export type {
    OrderByDescriptor,
    OrderByFields,
} from './query-builder/types/orderby/orderby-descriptor.type';
export type {
    QueryFilter,
    FilterFields,
    FilterOperators,
    LambdaFilterFields,
} from './query-builder/types/filter/query-filter.type';
export type { CombinedFilter } from './query-builder/types/filter/combined-filter.type';
export type { Guid } from './query-builder/types/utils/util.types';
export type { ExpandFields } from './query-builder/types/expand/expand-fields.type';

export { isCombinedFilter } from './query-builder/utils/filter/combined-filter-util';
export { isQueryFilter } from './query-builder/utils/filter/is-query-filter-util';

================
File: .eslintrc.json
================
{
    "env": {
        "browser": true,
        "es2021": true
    },
    "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended",
        "plugin:@typescript-eslint/recommended-requiring-type-checking",
        "plugin:@typescript-eslint/strict",
        "prettier"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "project": ["./tsconfig.json"],
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint",
        "prettier"
    ],
    "rules": {
        "@typescript-eslint/array-type": 0
    }
}

================
File: .gitignore
================
#builds
lib
coverage


### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

### Node Patch ###
# Serverless Webpack directories
.webpack/

# Optional stylelint cache

# SvelteKit build / generate output
.svelte-kit

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets

# Local History for Visual Studio Code
.history/

# Built Visual Studio Code Extensions
*.vsix

### VisualStudioCode Patch ###
# Ignore all local history of files
.history
.ionide

# Support for Project snippet scope
.vscode/*.code-snippets

# Ignore code-workspaces
*.code-workspace

### WebStorm+all ###
# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea/**/workspace.xml
.idea/**/tasks.xml
.idea/**/usage.statistics.xml
.idea/**/dictionaries
.idea/**/shelf

# AWS User-specific
.idea/**/aws.xml

# Generated files
.idea/**/contentModel.xml

# Sensitive or high-churn files
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# Gradle and Maven with auto-import
# When using Gradle or Maven with auto-import, you should exclude module files,
# since they will be recreated, and may cause churn.  Uncomment if using
# auto-import.
# .idea/artifacts
# .idea/compiler.xml
# .idea/jarRepositories.xml
# .idea/modules.xml
# .idea/*.iml
# .idea/modules
# *.iml
# *.ipr

# CMake
cmake-build-*/

# Mongo Explorer plugin
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive Clojure plugin
.idea/replstate.xml

# SonarLint plugin
.idea/sonarlint/

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based Rest Client
.idea/httpRequests

# Android studio 3.1+ serialized cache file
.idea/caches/build_file_checksums.ser

### WebStorm+all Patch ###
# Ignore everything but code style settings and run configurations
# that are supposed to be shared within teams.

.idea/*

!.idea/codeStyles
!.idea/runConfigurations
.DS_Store

================
File: .prettierrc
================
{
    "trailingComma": "all",
    "tabWidth": 4,
    "semi": true,
    "singleQuote": true,
    "bracketSpacing": true,
    "arrowParens": "avoid"
  }

================
File: CODE_OF_CONDUCT.md
================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
odata-builder.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

================
File: LICENSE
================
MIT License

Copyright (c) 2022 Marcel Wenner (nbyx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "odata-builder",
  "version": "0.6.1",
  "description": "odata builder for easier and typesafe usage",
  "author": "Marcel Wenner (https://github.com/nbyx)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/nbyx/odata-builder/issues"
  },
  "homepage": "https://github.com/nbyx/odata-builder#readme",
  "main": "dist/odata-builder.js",
  "scripts": {
    "build": "rollup --config rollup.config.js",
    "lint": "eslint --fix src/**",
    "format": "prettier --write --parser typescript '**/*.ts'",
    "generate-changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
    "test": "vitest",
    "test:cov": "vitest run --coverage"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nbyx/odata-builder.git"
  },
  "keywords": [
    "odata",
    "builder",
    "query",
    "odata v4",
    "odata client",
    "typescript",
    "angular",
    "react",
    "javascript",
    "typesafe"
  ],
  "lint-staged": {
    "*.ts": [
      "npm run format",
      "npm run lint",
      "git add"
    ]
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "@vitest/coverage-v8": "^1.0.4",
    "c8": "^8.0.1",
    "conventional-changelog-cli": "^4.1.0",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "prettier": "^3.1.1",
    "rollup-plugin-terser": "^7.0.2",
    "rollup-plugin-ts": "^3.4.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "vitest": "^1.0.4"
  }
}

================
File: README.md
================
# odata-builder
Generate Typesafe OData Queries with Ease. odata-builder ensures your queries are correct as you write them, eliminating worries about incorrect query formats.

[![build and test](https://github.com/nbyx/odata-builder/actions/workflows/ci-cd.yml/badge.svg?branch=main)](https://github.com/nbyx/odata-builder/actions/workflows/ci-cd.yml)
[![npm version](https://badge.fury.io/js/odata-builder.svg)](https://www.npmjs.com/package/odata-builder)

## Install
Install odata-builder using your preferred package manager:

```javascript
npm install --save odata-builder
```
or
```javascript
yarn add odata-builder
```
## Usage
Effortlessly create queries with typesafe objects:
```javascript
const item = {
    someProperty: 'someValue',
}

const queryBuilder = new OdataQueryBuilder<typeof item>()
    .count()
    .filter({field: 'someProperty', operator: 'eq', value: 'test'})
    .skip(10)
    .top(100)
    .select('someOtherProperty1', 'someOtherProperty2')
    .toQuery();
//  ^ ?$count=true&$filter=someProperty eq 'test'&$skip=10&$top=100&$select=someOtherProperty1, someOtherProperty2
```
### Count and Data Retrieval
For counting and data retrieval:

```javascript
const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>()
    .count(true)
    .filter(...) // only for demonstrating the count
    .toQuery();
//  ^ /$count?$filter=....
```
### Querying with GUID:
Decide on the inclusion of single quotes in GUID queries:
```javascript
import { Guid, OdataQueryBuilder } from 'odata-builder';

// You could type your id directly as guid
type MyAwesomeDto = {
    id: Guid;
    ...
}

const filter = {
    field: 'id',
    operator: 'eq'
    value: 'f92477a9-5761-485a-b7cd-30561e2f888b', // must be guid
    removeQuotes: true, // if not defined the guid will be added to the query with single quotes
}

const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>()
    .filter(filter)
    .toQuery();
//  ^ ?$filter=id eq some-guid

```
### Lambda Expressions for Array Filtering:
Utilize lambda expressions for filtering array fields:

```javascript
type MyAwesomeDto = {
    ...
    someProperty: string[]
    ...
}

const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>()
    .filter({
        field: 'someProperty',
        operator: 'contains',
        value: 'test',
        lambdaOperator: 'any',
        ignoreCase: true,
    })
    .toQuery();
//  ^ ?$filter=someProperty/any(s: contains(tolower(s), 'test'));
```

### Filtering Objects in Arrays:
Filter within arrays of objects:
```javascript
type MyAwesomeDto = {
    ...
    someProperty: { someInnerProperty: string }[]
    ...
}

const queryBuilder = new OdataQueryBuilder<MyAwesomeDto>()
    .filter({
        field: 'someProperty',
        operator: 'contains',
        value: 'test',
        lambdaOperator: 'any',
        innerProperty: 'someInnerProperty', // <-- you will also get autocomplete for this property
        ignoreCase: true,
    })
    .toQuery();
//  ^ ?$filter=someProperty/any(s: contains(tolower(s/someInnerProperty), 'test'));

```

### Combined Filters:
Combine multiple filters:

```javascript
 const queryBuilder = new ODataQueryBuilder<MyAwesomeDto>
    .filter({
        logic: 'or',
        filters: [
            { field: 'x', operator: 'eq', value: 'test' },
            { field: 'y', operator: 'eq', value: 5 },
        ],
    })
    .toQuery();
//  ^ ?$filter=(x eq test or y eq 5)
```
### Function Encapsulation:
Encapsulate query creation:

```javascript
const item = {
    x: 4,
    y: 'test',
    z: new Date(Date.now()),
};

const testFn = (
    field: FilterFields<typeof item, string>, // you can use that type to get only the fields with type string
    operator: FilterOperators<string>, // only allows filter operators for the given type
    value: string, // you should use the type that you have defined in the FilterFields type
): string => {
    const queryBuilder = new OdataQueryBuilder<typeof item>();

    queryBuilder.filter({ field, operator, value });

    return queryBuilder.toQuery();
};

const result = testFn('y', 'eq', 'test');
//  ^ ?$filter=y eq 'test'
```
### Property Expansion:
Expand properties in queries:

```javascript
const item = {
    x: { someProperty: '' },
}
const queryBuilder = new OdataQueryBuilder<typeof item>();
    .expand('x')
    .toQuery();
//  ^ ?expand=x  
```

You can do this with inner properties as well:

```javascript
const item = {
    x: { someProperty: { nestedProperty: '' } },
}
const queryBuilder = new OdataQueryBuilder<typeof item>();
    .expand('x/someProperty') // you will get autocomplete for these properties
    .toQuery();
//  ^ ?expand=x/someProperty 
```
# Features
* Generate oData4 queries with typesafe objects.
    * Check of field, value and possible operator for a filter
    * Orderby, Select only fields of your model
    * **Autocomplete** for every property in your filter, orderby, etc...
    * Filtering of arrays in your model
    * Filters can be added with strings that will get typechecked
* Generate Queries to manipluate data (soon™)
# ToDos
- [x] Add **select** query
- [x] Add **orderby** with order direction asc or desc
- [x] Add single **filter** support with lambda expressions
- [x] Add expand support
- [ ] Add odata function support (partially done)
- [ ] Add search support
- [ ] Add support for data modification queries with odata 

Your contributions are welcome! If there's a feature you'd like to see in odata-builder, or if you encounter any issues, please feel free to open an issue or submit a pull request.

================
File: rollup.config.js
================
import typescript from 'rollup-plugin-ts';
import { terser } from 'rollup-plugin-terser';

export default {
  input: './src/index.ts',
  plugins: [typescript(), terser()],
  output: [
    {
      file: './dist/odata-builder.esm.js',
      format: 'esm',
      exports: 'auto'
    },
    {
      file: './dist/odata-builder.js',
      format: 'cjs',
      exports: 'auto'
    },
  ],
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2019",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    "lib": ["ESNext", "DOM"],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    "allowJs": false,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}
